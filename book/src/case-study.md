## Case study: Implied bounds and perfect derive

The current code doesn't really model Rust as it is today. It actually models Rust extended with support for two new features, "implied bounds" and "perfect derive":

* **Implied bounds:** Given `struct Foo<T: Ord>`, can `impl<T> Foo<T> { ... }` just know that `T: Ord`?
    * (We actually have implied bounds today, but they are limited to supertraits (e.g., `T: Eq => T: PartialEq`), so maybe a better way to describe implied bounds would be *expanded implied bounds*.)
* **Perfect derive:** Given `#[derive(Clone)] struct Foo<T> { x: Rc<T> }`, we "just know" that `impl<T> Clone for Foo<T>` works, and that `T: Clone` is not necessary?
    * The idea is that `derive` would generate `impl<T> Clone for Foo<T> where Rc<T>: Clone`. Seems simple, right?
    * The trick is that we have to extend all trait matching to work like auto-traits does, and accept cycles. Consider deriving clone on
        * `struct List<T> { value: Rc<T>, next: Option<Rc<List<T>>> }`
        * here you would get `impl<T> Clone for List<T> where Rc<T>: Clone, Option<Rc<List<T>>>: Clone` -- if you try that today, you'll find it is a cycle error.
    * We are going to refer to this "accept cycles" as coinductive; it's basically the [co-LP formulation by Luke Simon et al.](https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.102.9618&rep=rep1&type=pdf) that I referred to earlier.

These two features are a bit tricky to integrate because accepting cycles, if you're not careful, can easily lead you into assuming implied bounds that are not true. The classic example is this:

```rust
trait Copy { }
trait Magic: Copy { }
```

Clearly, given these traits, we know that `T: Magic => T: Copy`, right? But what about if someone writes this rather tautological impl:

```rust
impl<T: Magic> Magic for T { }
```

If we're not careful, we can use this impl to show that every type implements `Magic` -- and yet there is no `impl Copy` anywhere. Something is off!

The solution to that is based on the scheme that [scalexm](https://github.com/scalexm) invented for Chalk; I've tweaked it somewhat by integrating it a bit more deeply into the "core logic", which simplifies the predicates that we need. I find I like this formulation better, and it allows us to simplify a few other things too.

### Distinguish `HasImpl` and `Implemented`

The first key part of the system is to distinguish *having an impl* (`HasImpl`) from *being implemented* (`Implemented`). The former says that the user wrote an impl. The latter says that all the requirements are met to implement the trait, including in particular that all of its where clauses (which includes the supertraits) are satisfied.

Using the code for impls we saw earlier, the `Magic` impl would generate the following clause:

```scheme
; forall<T> { Implemented(T: Magic) => HasImpl(T: Magic) }
(ForAll ((TyKind T)) 
        (Implies ((Implemented (Magic (T))))
                 (HasImpl (Magic (T)))))
```

To actually prove `Implemented(T: Magic)`, This clause has to be combined with the clauses generated by the trait declarations ([source](https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/decl/decl-to-clause.rkt#L95-L118)). For the `Copy` trait, which has no where clauses, this clause is very simple. To be implemented, the impl must exist, and the type must be well-formed:

```scheme
; forall<T> { (
;               HasImpl(T: Copy), 
;               WellFormed(T),
;             ) => Implemented(T: Copy) }
(ForAll ((TyKind T))
        (Implies ((HasImpl (Copy (T)))
                  (WellFormed (TyKind (T))))
                 (Implemented (Copy (T)))))
```

For `Magic`, the rule includes the where clause that `T: Copy`:

```schheme
; forall<T> { (
;               HasImpl(T: Magic), 
;               WellFormed(T),
;               Implemented(T: Copy),
;             ) => Implemented(T: Magic) }
(ForAll ((TyKind T))
        (Implies ((HasImpl (Magic (T)))
                  (WellFormed (TyKind (T)))
                  (Implemented (Copy (T))))
                 (Implemented (Magic (T)))))
```

Now we start to see how this works -- if I want to call a function with a `T: Magic` where clause, like this...

```rust
fn make_the_magic_happen<T: Magic>(t: T) {
    let u = t;
    drop((t, u)); // both t, u are valid
}
```

...it is not enough to show that `HasImpl` is satisfied, I also have to prove that `T: Copy`. To do that, I have to show that `HasImpl(T: Copy)`, and I can't do that.

### But wait, implied bounds?

Actually though, the above is not sufficient to solve the problem. That's because we haven't added in implied bounds yet! The *naive* version of implied bounds is that we want to add in a rule like so:

```
Implemented(T: Magic) => Implemented(T: Copy)
```

i.e., if I know that `T: Magic`, I also know that `T: Copy`. But if we literally added that clause, it would be unsound, at least in a coinductive setting. Why is that? Say I want to prove that `String: Copy`...

* `Implemented(String: Copy)`? Well, that's true if...
    * `Implemented(String: Magic)`? Well, that's true if...
        * `HasImpl(String: Magic)`? Well, that's true if...
            * `Implemented(String: Magic)` -- and that's on the stack, so that's ok!
        * `WellFormed(String)` -- yep
        * `Implemented(String: Copy)` -- well, that's on the stack, so that's ok!

The traditional solution so this sort of problem is to impose some kind of limits on the impls people can write so they must be "productive". It's a bit tricky to define what productivity means, but intuitively it means "not tautological". The challenge is that the various schemes I've seen for showing productivity don't accept impls like the ones that perfect derive would create, so they wouldn't really work for us. The solution in the impl works a different way.

The co-LP formulation acccepts any cycle as valid, so it's very easy to create these kind of "tautological rules". Now, if the user actually *wrote* those impls, I don't see that as a problem. It's ok to have mutually dependent impls, all we want to know basically is "when I call a method, there will be some impl to go to" (see example below). But it's not good if it's unsound. =)

```rust
trait Foo {
    fn foo(&self);
}

trait Bar {
    fn bar(&self);
}

impl<T: Bar> Foo for T {
    fn foo(&self) {
        if something() { self.bar() }
    }
}

impl<T: Foo> Bar for T {
    fn bar(&self) {
        if something() { self.foo() }
    }
}
```

### Enter: invariants

The insight is that it's not ok to use implied bounds out of thin air. You only want to use them for where-clauses that you have in scope. In this way, they are categorically different from program clauses, which always hold. I've decided to refer to implied bounds as *invariants* -- the idea is that they are things which "must be true if the program is valid". So for our program we would have one **invariant**:

```
forall<T> { Implemented(T: Magic) => Implemented(T: Copy) }
```

To express this a bit more formally, let `F` be the set of all "facts" we can generate from the clauses alone (a "fact" here is just a predicate that refers to some concrete types and thing)s. Because there are an infinite set of types, the set of facts is also infinite, but that's ok. In our example, given the rules we've seen so far (but ignoring the implied bound), we can show that `HasImpl(i32: Magic)` and `HasImpl(u32: Magic)` easily enough. We don't have a `HasImpl(i32: Copy)` fact, though, and because of that we also can't have a `Implemented(i32: Copy)` fact. Given this set of facts `F`, then we ought to be able to prove each invariant `I`, or something is broken in our type rules. In our example, the invariant `forall<T> { Implemented(T: Magic) => Implemented(T: Copy) }` does in fact hold, because there are no `Implemented(T: Magic)` facts.

### Integrating invariants into the solver

The solver is able to make use of invariants to generate proofs, but only in a limited way. Whereas we can always use a program clause, we can only apply invariants to the *hypotheses* that are in scope -- a *hypotheses* is some where-clause that we are assuming to be true. The idea here is that the caller must have proven that hypothesis to be a *fact* -- if they did so, then unless our type rules are broken, the invariant holds, which means that any facts we can derive with the invariants are also true.

This in turn implies that the seemingly tautological impl of `Magic` is actually **legal**! Recall the "ok goals" we saw before, that are used to decide which declarations are legal. The "ok" goal for the magic impl looks like this:

```scheme
(ForAll ((TyKind T))
        (Implies ((Implemented (Magic (T))))
                 (Implemented (Magic (T)))))
```

Basically, "if we assume that `T: Magic` is implemented, then we can show that `T: Magic` is implemented". Well, that's obviously true.

OK, so the impl is legal, but what about this function `make_the_magic_happen`?

```rust
fn make_the_magic_happen<T: Magic>(t: T) {
    let u = t;
    drop((t, u)); // both t, u are valid
}
```

We don't currently have type-checking logic in formality but, if we did, type-checking this function would require copying `t` and hence proving that:

```
forall<T> {
    Implemented(T: Magic) => Implemented(T: Copy)
}
```

Here the `Implemented(T: Magic) => ...` comes from the where-clauses on the function. To solve this, the solver puts `Implemented(T: Magic)` into the environment as a hypothesis using the "prove-implies" rule ([source](https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/ty/cosld-solve/prove.rkt#L67-L71)):

```scheme
  [(where Env_1 (env-with-hypotheses Env Hypotheses))
   (prove Env_1 Predicates_stack Goal EnvSubstitution_out)
   -------------------------------------------------------- "prove-implies"
   (prove Env Predicates_stack (Implies Hypotheses Goal) (reset Env () EnvSubstitution_out))
   ]
```

Next it can apply the "prove-hypothesis-imply" rule ([source](https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/ty/cosld-solve/prove.rkt#L41-L45)):

```scheme
  [(where #f (in? Predicate Predicates_stack))
   (Hypotheses-imply Env () Predicate EnvSubstitution_out)
   --------------- "prove-hypotheses-imply"
   (prove Env Predicates_stack Predicate EnvSubstitution_out)
   ]
```

This rule usess [`Hypotheses-imply`](https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/ty/cosld-solve/hypothesize.rkt#L9-L11), another typing judgment which determines whether `Predicate` is either *directly* in the environment as a hypothesis **or can be derived via an invariant**. This last part is what we need here! The only hypothesis in the environment is `Implemented(T: Magic)`, but we can use the invariant

```
Implemented(T: Magic) => Implemented(T: Copy)
```

to expand that to `Implemented(T: Copy)`, so we are happy.

### Wait, so is this sound?

But accepting this impl and this function this doesn't mean we have an unsound program -- the question is, who is going to *call* that function, and with what type? And this is where the errors come in. Consider this `main` function:

```rust
fn main() {
    make_the_magic_happen("Die, cruel world, die!".to_string());
}
```

For this program to type-check, we must prove the where-clauses on `make_the_magic_happen`, which means proving

```
Implemented(String: Magic)
```

But in this case, there are no hypotheses in the environment, so we can't make use of the invariants. We have to use the program clause, it requires also showing that `Implemented(String: Copy)` which in turn means showing `HasImpl(String: Copy)`, and we cannot do that.

Thinking a bit more abstractly, no matter what where clauses we have on various functions, we will "bottom out" in a `main` function somewhere, and `main` has no where clauses. Therefore, if our program relies on `Implemented(i32: Magic)`, that must be provable in an environment with no hypotheses. Put another way, `Implemented(i32: Magic)` must be a member of that infinite set of facts that we described earlier, the ones which categorize "everything that is true in this program". But we already argued that this set does not include `Implemented(i32: Magic)`, because the only way to get such a fact is to use the program clause, and the program clause requires that `HasImpl(i32: Copy)`, which is not true.

### Productivity again?

xxx -- didn't get time to to finish this, but I think that you can frame the previous two sections in terms of the typical "productivity" rules. There is a nice thesis I've been slowly working through on this. The TL;DR is something like this: "we accept all cycles but require that for any proof of `Implemented(T: Foo)`, `HasImpl(T: Foo)` must appear somewhere in the cycle", but that's not quite stating it right.

# Case study: Implied bounds and perfect derive
